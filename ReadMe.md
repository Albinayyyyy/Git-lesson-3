# Инструкция для работы с Git и удалёнными репозиториями

## Что такое Git?
Git - это одна из реализаций распределённых систем контроля версий, имеющая как и локальные, так и удалённые репозитории. Является самой популярной реализацией систем контроля версий в мире.
## Подготовка репозитория
Для создание репозитория необходимо выполнить команду *git init*  в папке с репозиторием и у Вас создаться репозиторий (появится скрытая папка .git)

## Создание коммитов

### Git add
Для добавления измений в коммит используется команда *git add*. Чтобы использовать команду *git add* напишите *git add <имя файла>*

### Просмотр состояния репозитория
Для того, чтобы посмотреть состояние репозитория используется команда *git status*. Для этого необходимо в папке с репозиторием написать *git status*, и Вы увидите были ли измения в файлах, или их не было.

### Создание коммитов
Для того, чтобы создать коммит(сохранение) необходимо выполнить команду *git commit*. Выполняется она так: *git commit -m "<сообщение к коммиту>*. Все файлы для коммита должны быть ***ДОБАВЛЕНЫ*** и сообщение к коммиту писать ***ОБЯЗАТЕЛЬНО***.

## Перемещение между сохранениями
Для того, чтобы перемещаться между коммитами, используется команда *git checkout*. Используется она в папке с пепозиторием следующим образом: *git checkout <номер коммита>*

## Журнал изменений
Для того, чтобы посмтреть все сделанные изменения в репозитории, используется команда *git log*. Для этого достаточно выполнить команду *git log* в папке с репозиторием

## Ветки в Git

### Создание ветки

Для того, чтобы создать ветку, используется команда *git branch*. Делается это следующим образом в папке с репозиторием: *git branch <название новой ветки>*

## Слияние веток

Для того чтобы дабавить ветку в текущую ветку используется команда *git merge <name branch>*

## Удаление веток
Для удаления ветки ввести команду "git branch -d 'name branch'"

# Основы работы с удаленным репозиторием

## git clone — создание копии (удаленного) репозитория

Для начала работы с центральным репозиторием, следует создать копию оригинального
проекта со всей его историей локально.

Клонирует репозиторий, используя протокол http:
```
git clone http://user@somehost:port/~user/repository/project.git
```

Клонирует репозиторий с той же машины в директорию myrepo:
```
git clone /home/username/project myrepo
```

Клонирует репозиторий, используя безопасный протокол ssh:
```
git clone ssh://user@somehost:port/~user/repository
```

У git имеется и собственный протокол:
```
git clone git://user@somehost:port/~user/repository/project.git/
```

Импортирует svn репозиторий, используя протокол http:
```
git svn clone -s http://repo/location
```
где -s – понимать стандартные папки SVN (trunk, branches, tags)


## git fetch и git pull — забираем изменения из центрального репозитория

Для синхронизации текущей ветки с репозиторием используются команды git fetch
и git pull.

git fetch — забирает изменения удаленной ветки из репозитория по умолчания,
основной ветки; той, которая была использована при клонировании репозитория.
Изменения обновят удаленную ветку (remote tracking branch), после чего надо будет
провести слияние с локальной ветку командой git merge.

Получает изменений из определенного репозитория:
```
git fetch /home/username/project
```

Возможно также использовать синонимы для адресов, создаваемые командой git remote:
```
git remote add username-project /home/username/project
git fetch username-project
```

Естественно, что после оценки изменений, например, командой git diff, надо
создать коммит слияния с основной:
```
git merge username-project/master
```

Команда git pull сразу забирает изменения и проводит слияние с активной веткой.
Забирает из репозитория, для которого были созданы удаленные ветки по умолчанию:
```
git pull
```

Забирает изменения и метки из определенного репозитория:
```
git pull username-project --tags
```

Как правило, используется сразу команда git pull.

## git push — вносим изменения в удаленный репозиторий

После проведения работы в экспериментальной ветке, слияния с основной, необходимо
обновить удаленный репозиторий (удаленную ветку). Для этого используется команда
git push.

Отправляет свои изменения в удаленную ветку, созданную при клонировании по
умолчанию:
```
git push
```

Отправляет изменения из ветки master в ветку experimental удаленного репозитория:
```
git push ssh://yourserver.com/~you/proj.git master:experimental
```

В удаленном репозитории origin удаляет ветку experimental:
```
git push origin :experimental
```

Отправляет в удаленную ветку master репозитория origin (синоним репозитория по
умолчанию) ветки локальной ветки master:
```
git push origin master:master
```

Отправляет метки в удаленную ветку master репозитория origin:
```
git push origin master --tags
```

Изменяет указатель для удаленной ветке master репозитория origin (master будет
такой же как и develop):
```
git push origin origin/develop:master
```

Добавляет ветку test в удаленный репозиторий origin, указывающую на коммит ветки
develop:
```
git push origin origin/develop:refs/heads/test
```

## Ветвление
### git branch — создание, перечисление и удаление веток

Работа с ветками — очень легкая процедура в git, все необходимые механизмы
сконцентрированы в одной команде.

Просто перечисляет существующие ветки, отметив активную:
```
git branch
```

Создаёт новую ветку new-branch:
```
git branch new-branch
```

Удаляет ветку, если та была залита (merged) с разрешением возможных конфликтов в
текущую:
```
git branch -d new-branch
```

Удаляет ветку в любом случае:
```
git branch -D new-branch
```

Переименовывает ветку:
```
git branch -m new-name-branch
```

Показывывает те ветки, среди предков которых есть определенный коммит:
```
git branch --contains v1.2
```

Показывает коммит ответвления ветки new-name-branch от ветки master:
```
git merge-base master new-name-branch
```

### git checkout — переключение между ветками, извлечение файлов

Команда git checkout позволяет переключаться между последними коммитами (если
упрощенно) веток:
```
checkout some-other-branch
```

Создаёт ветку, в которую и произойдет переключение:
```
git checkout -b some-other-new-branch
```

Если в текущей ветке были какие-то изменения по сравнению с последним коммитом в
ветке(HEAD), то команда откажется производить переключение, дабы не потерять
произведенную работу. Проигнорировать этот факт позволяет ключ -f:
```
git checkout -f some-other-branch
```

В случае, когда изменения надо все же сохранить, следует использовать ключ -m.
Тогда команда перед переключением попробует залить изменения в текущую ветку и,
после разрешения возможных конфликтов переключиться в новую:
```
git checkout -m some-other-branch
```

Вернуть файл (или просто вытащить из прошлого коммита) позволяет команда вида:
```
git checkout somefile
```

Возвращает somefile к состоянию последнего коммита:
```
git checkout somefile
```

Возвращает somefile к состоянию на два коммита назад по ветке:
```
git checkout HEAD~2 somefile
```

### git merge — слияние веток, разрешение возможных конфликтов

Слияние веток, в отличие от обычной практики централизованных систем, в git
происходит практически каждый день. Естественно, что имеется удобный интерфейс
к популярной операции.

Пытается объединить текующую ветку и ветку new-feature:
```
git merge new-feature
```

В случае возникновения конфликтов коммита не происходит, а по проблемным файлам
расставляются специальные метки а-ля svn; сами же файлы отмечаются в индексе как
«не соединенные» (unmerged). До тех пор пока проблемы не будут решены, коммит
совершить будет нельзя.

Например, конфликт возник в файле TROUBLE, что можно увидеть в git status.

Произошла неудачная попытка слияния:
```
git merge experiment
```

Смотрим на проблемные места:
```
git status
```

Разрешаем проблемы:
```
edit TROUBLE
```

Индексируем наши изменения, тем самым снимая метки:
```
git add .
```

Совершаем коммит слияния:
```
git commit
```

Вот и все, ничего сложного. Если в процессе разрешения вы передумали разрешать
конфликт, достаточно набрать (это вернёт обе ветки в исходные состояния):
```
git reset --hard HEAD
```

Если же коммит слияния был совершен, используем команду:
```
git reset --hard ORIG_HEAD
```

### git rebase — построение ровной линии коммитов

Предположим, разработчик завел дополнительную ветку для разработки отдельной
возможности и совершил в ней несколько коммитов. Одновременно по какой-либо
причине в основной ветке также были совершены коммиты: например, в нее были
залиты изменения с удаленного сервера, либо сам разработчик совершал в ней
коммиты.

В принципе, можно обойтись обычным git merge. Но тогда усложняется сама линия
разработки, что бывает нежелательно в слишком больших проектах, где участвует
множество разработчиков.

Предположим, имеется две ветки, master и топик, в каждой из которых было
совершенно несколько коммитов начиная с момента ветвления. Команда git rebase
берет коммиты из ветки topic и накладывает их на последний коммит ветки master.

Вариант, в котором явно указывается, что и куда накладывается:
```
git-rebase master topic
```
на master накладывается активная в настоящий момент ветка:
```
git-rebase master
```

После использования команды история становится линейной. При возникновении
конфликтов при поочередном накладывании коммитов работа команды будет
останавливаться, а в проблемные местах файлов появятся соответствующие метки.
После редактирования, разрешения конфликтов, файлы следует внести в индекс
командой:
```
git add
``` 
и продолжить наложение следующих коммитов командой:
```
git rebase --continue
``` 

Альтернативными выходами будут команды пропустить наложение коммита и перейти к
следующему:
```
git rebase --skip 
```
и отмена работы команды и всех внесенных изменений:
```
git rebase --abort 
```

С ключом -i (--interactive) команда будет работать в интерактивном режиме.
Пользователю будет предоставлена возможность определить порядок внесения
изменений, автоматически будет вызывать редактор для разрешения конфликтов и
так далее.

### git cherry-pick — применение к дереву проекта изменений, внесенных отдельным коммитом

Если ведется сложная история разработки, с несколькими длинными ветками
разработками, может возникнуть необходимость в применении изменений, внесенных
отдельным коммитом одной ветки, к дереву другой (активной в настоящий момент).

Изменения, внесенные указанным коммитом будут применены к дереву, автоматически
проиндексированы и станут коммитом в активной ветке:
```
git cherry-pick BUG_FIX_TAG
```

Ключ -n показывает, что изменения надо просто применить к дереву проекта без
индексации и создания коммита:
```
git cherry-pick BUG_FIX_TAG -n
```

### git worktree - одновременная работа с несколькими ветками
Git позволяет работать одновременно с несколькими ветками одного репозитория.
Для добавления ветки в отдельную директорию необходимо выполнить команду:
```
git worktree add path/ remote/master
```
Для просмотра всех директориев с ветками можно воспользоваться командой:
```
git worktree list
```
Директорию с веткой можно перести в другое место с помощью команды:
```
git worktree move old-path/ new-path/
```
После окончания работы с веткой в директории, её  можно удалить командой:
```
git worktree remove path/ 
```

## Подмодули
### Клонирование репозитория с подмодулями
При клонировании репозитория вам необходимо инициализировать и обновить подмодули:
```
$ git clone --recursive https://github.com/username/repo.git
```
Запуск данной команды эквивалентен запуску команды:
```
git submodule update --init --recursive
```
после обычного клонирования репозитория

### Обновление подмодулей
Подмодуль ссылается на конкретную коммит в другом репозитории. Чтобы получить 
точное состояние всех подмодулей необходимо запустить:
```
git submodule update --recursive
```
Для получения состояния последнего коммита всех подмодулей необходимо выполнить 
следующую команду:
```
git submodule foreach git pull origin master
```
или использовать аргументы по умолчанию команды git pull:
```
git submodule foreach git pull
```
Эта команда просто обновляет локальную рабочую копию. При запуске команды git status 
каталоги подмодулей будут показаны изменёнными. Чтобы обновить репозиторий необходимо 
зафиксировать изменения:
```
git add submodule_directory
git commit
```
Для получения состояние последнего коммита конкретного подмодуля необходимо использовать команду:
```
git submodule update --remote submodule_directory
```

### Добавление подмодулей
В текущий проект можно включить другой репозиторий Git в качестве папки, отслеживаемый Git:
```
git submodule add https://github.com/jquery/jquery.git
```
После этого необходимо добавить и зафиксировать новый файл .gitmodules. В нём описано 
какие подмодули следует клонировать при запуске команды git submodule update

### Перемещение подмодулей
Для перемещение подмодуля из одного места репозитория в другое место репозитория 
необходимо выполнить команду:
```
git mv /path/to/module new/path/to/module
```

### Удаление подмодулей
Для удаления подмодуля из репозитория необходимо удалить описание подмодуля
и каталог с файлами подмодуля:
```
git submodule deinit the_submodule
git rm the_submodule
```

## Прочие команды и необходимые возможности
### Хэш — уникальная идентификация объектов

В git для идентификации любых объектов используется уникальный (то есть с
огромной вероятностью уникальный) хэш из 40 символов, который определяется
хэшируюшей функцией на основе содержимого объекта. Объекты — это все: коммиты,
файлы, тэги, деревья. Поскольку хэш уникален для содержимого, например, файла,
то и сравнивать такие файлы очень легко — достаточно просто сравнить две строки
в сорок символов.

Больше всего нас интересует тот факт, что хэши идентифицируют коммиты. В этом
смысле хэш — продвинутый аналог ревизий Subversion. Несколько примеров
использования хэшей в качестве способа адресации.

Ищет разницу текущего состояния проекта и коммита за номером… сами видите,
каким:
```
git diff f292ef5d2b2f6312bc45ae49c2dc14588eef8da2
```

То же самое, но оставляем только шесть первых символов. Git поймет, о каком
коммите идет речь, если не существует другого коммита с таким началом хэша:
```
git diff f292ef5
```

Иногда хватает и четырех символов:
```
git diff f292
```

Читает лог с коммита по коммит:
```
git log febc32...f292
```

Разумеется, человеку пользоваться хэшами не так удобно, как машине, именно
поэтому были введены другие объекты — тэги.

### git tag — тэги как способ пометить уникальный коммит

Тэг (tag) — это объект, связанный с коммитом; хранящий ссылку на сам коммит,
имя автора, собственное имя и некоторый комментарий. Кроме того, разработчик
может оставлять на таких тегах собственную цифровую подпись.

Кроме этого в git представленные так называемые «легковесные тэги» (lightweight
tags), состоящие только из имени и ссылки на коммит. Такие тэги, как правило,
используются для упрощения навигации по дереву истории; создать их очень легко.

Создаёт «легковесный» тэг, связанный с последним коммитом; если тэг уже есть,
то еще один создан не будет:
```
git tag stable-1
```

Помечает определенный коммит:
```
git tag stable-2 f292ef5
```

Удаляет тег:
```
git tag -d stable-2
```

Перечисляет тэги:
```
git tag -l
```

Создаёт тэг для последнего коммита, заменяет существующий, если таковой уже был:
```
git tag -f stable-1.1
```

После создания тэга его имя можно использовать вместо хэша в любых командах
вроде git diff, git log и так далее:
```
git diff stable-1.1...stable-1
```

Обычные тэги имеет смысл использовать для приложения к коммиту какой-либо
информации, вроде номера версии и комментария к нему. Иными словами, если в
комментарии к коммиту пишешь «исправил такой-то баг», то в комментарии к тэгу по
имени «v1.0» будет что-то вроде «стабильная версия, готовая к использованию».

Создаёт обычный тэг для последнего коммита; будет вызван текстовый редактор для
составления комментария:
```
git tag -a stable
```

Создаёт обычный тэг, сразу указав в качестве аргумента комментарий:
```
git tag -a stable -m "production version"
```

Команды перечисления, удаления, перезаписи для обычных тэгов не отличаются от
команд для «легковесных» тэгов.

### Относительная адресация

Вместо ревизий и тэгов в качестве имени коммита можно опираться на еще один
механизм — относительную адресацию. Например, можно обратиться прямо к предку
последнего коммита ветки master:
```
git diff master^
```

Если после «птички» поставить цифру, то можно адресоваться по нескольким предкам
коммитов слияния:
```
git diff HEAD^2
```
Ищет изменения по сравнению со вторым предком последнего коммита в master; HEAD
здесь — указатель на последний коммит активной ветки.

Аналогично, тильдой можно просто указывать, насколько глубоко в историю ветки
нужно погрузиться.

Что привнес «дедушка» нынешнего коммита:
```
git diff master^^
```

То же самое:
```
git diff master~2
```

Обозначения можно объединять, чтобы добраться до нужного коммита:
```
git diff master~3^~2
git diff master~6
```

### Файл .gitignore — объясняем git, какие файлы следует игнорировать

Иногда по директориям проекта встречаются файлы, которые не хочется постоянно
видеть в сводке git status. Например, вспомогательные файлы текстовых редакторов,
временные файлы и прочий мусор.

Заставить git status игнорировать определенные файлы можно, создав в корне или
глубже по дереву (если ограничения должны быть только в определенных директория)
файл .gitignore. В этих файлах можно описывать шаблоны игнорируемых файлов
определенного формата.

Пример содержимого такого файла:
```
#комментарий к файлу .gitignore
#игнорируем сам .gitignore
.gitignore
#все html-файлы...
*.html
#...кроме определенного
!special.html
#не нужны объектники и архивы
*.[ao]
```

Существуют и другие способы указания игнорируемых файлов, о которых можно узнать
из справки git help gitignore.

# Серверные команды репозитория

Команда создания вспомогательных файлов для dumb-сервера в $GIT_DIR/info и
$GIT_OBJECT_DIRECTORY/info каталогах, чтобы помочь клиентам узнать, какие ссылки
и пакеты есть на сервере:
```
git update-server-info
```

Проверяет сколько объектов будет потеряно и объём освобождаемого места при
перепаковке репозитория:
```
git count-objects
```

Переупаковывает локальный репозиторий:
```
git gc
```

# Рецепты
## Создание пустого репозитория на сервере

```
repo="repo.git" 
mkdir $repo
cd $repo
git init --bare
chown git. -R ./
cd ../
```

## Импорт svn репозитория на Git-сервер
```
repo="repo.svn" 
svnserver="http://svn.calculate.ru" 
git svn clone -s $svnserver/$repo $repo
mv $repo/.git/refs/remotes/tags $repo/.git/refs/tags
rm -rf $repo/.git/refs/remotes
rm -rf $repo/.git/svn
mv $repo/.git $repo.git
rm -rf $repo
cd $repo.git
chown git. -R ./
cd ../
```

## Связка локальной и удаленной ветки

Отправление ветки local в удаленный репозиторий и установка локальной ветки
local отслеживаемой с origin/local:
```
git push -u origin local
```

Пометка локальной ветки как отслеживаемой с origin/local:
```
git branch --set-upstream-to=origin/local
```

## Создание новой пустой ветки

Создание пустой ветки с именем newbranch:
```
git checkout --orphan newbranch
```

Удаление файлов:
```
git rm -rf .
```

## Использование Git для получения версии

Установка начала новой версии на текущий коммит:
```
git tag v1.0-dev
```

Получение номера версии для последующие коммитов:
```
git describe --tags
v1.0-dev-3-g387f83f
```
где
   * v1.0-dev — имя тега
   * 3 — количество коммитов после этого тега (0 если тэг поставлен на текущий коммит)
   * 387f83f — короткий хэш текущего коммита.
   
